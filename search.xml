<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>vector用法总结</title>
    <url>/2020/04/12/vector/</url>
    <content><![CDATA[<h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h3><p>首先，我们来看一下vector初始化的几种方法，以及对这几种初始化下的容量大小分析：</p>
<h4 id="（1）-无参初始化"><a href="#（1）-无参初始化" class="headerlink" title="（1） 无参初始化"></a>（1） 无参初始化</h4><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; a;
    cout&lt;&lt;a.size();
    return 0;
}</code></pre><p>这种初始方法最为简便，容器容量随着元素的增多而增多；</p>
<h4 id="（2）-带有容量参数的初始化"><a href="#（2）-带有容量参数的初始化" class="headerlink" title="（2） 带有容量参数的初始化"></a>（2） 带有容量参数的初始化</h4><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; a(2);
    a.push_back(1);
    cout&lt;&lt;a.size();
    return 0;
}</code></pre><p>在未push_back前输出结果是2,插入一个元素后输出结果变为3，也就是说容器容量在初始化的基础上仍然会随着元素的push增多，这种情况下初始化数值为0，也可以指定初始化数值，<code>vector&lt;int&gt; a(2,100)</code>,即创建一个大小为2，初始化为100的vector；但是与第一种无参初始化有些不同：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; a(2);
    a[1]=88;
    cout&lt;&lt;a.size();
    return 0;
}</code></pre><p>可以看出当有了初始化容量之后，就相当于一个相同容量的初始化为0的可改变大小的数组，此时可以根据元素下标去访问，这里对a[1]复制后容量仍为2，vector值变成{0，88}；</p>
<p><img src="/.xyz//vector-2.png" alt></p>
<h4 id="3-使用数组初始化"><a href="#3-使用数组初始化" class="headerlink" title="(3) 使用数组初始化"></a>(3) 使用数组初始化</h4><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    int aa[2] = {1,2};
    vector&lt;int&gt; a(aa,aa+2);
    int size = a.size();
    return 0;
}</code></pre><p><img src="/.xyz//vector-3.png" alt></p>
<p>如果这里在推入数据会怎么样呢？</p>
<p><img src="/.xyz//vector-3-2.png" alt></p>
<p>可以看出不管在什么情况下，vector都是可以进行增长的，不过需要注意的是，千万不要用下标访问未存在的地址，如果出现段错误等地址形式的错误可以看看这个方向。另外还需要提及到的一点是用初始化数组的方式初始化vector也是可以的，比如<code>vector&lt;int&gt; a={1,2,3};</code></p>
<p><img src="/.xyz//vector-3-3.png" alt></p>
<h3 id="2-数据的增删改查"><a href="#2-数据的增删改查" class="headerlink" title="2. 数据的增删改查"></a>2. 数据的增删改查</h3><h4 id="（1）push-back"><a href="#（1）push-back" class="headerlink" title="（1）push_back()"></a>（1）push_back()</h4><p>最基本的数据增加方法，在最后插入，不多说；</p>
<h4 id="（2）insert"><a href="#（2）insert" class="headerlink" title="（2）insert()"></a>（2）insert()</h4><p>insert()一般用的情况就是在头处插入，insert的用法一般是有三种：1.直接指定位置指定插入数据；2.在1的情况下同时指定重复的次数；3.指定插入位置和另一个数组或vector的起始位置，演示代码：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; a={1,2,3};
    vector&lt;int&gt;::iterator it=a.begin();
    a.insert(it,0);
    it=a.end();
    a.insert(it,4);
    vector&lt;int&gt; b={7,8};
    b.insert(b.begin(),a.begin(),a.end());
    b.insert(b.end(),4,10);
       return 0;
}</code></pre><p><img src="/.xyz//vector-4.png" alt></p>
<p>不过此处有一点需要注意：当使用iterator来作为插入位置标识的时候，需要注意，当插入成功后，如果仍想在此处插入，需要更新it的值，比如it=a.begin();当插入0成功后，it指向的不是0，而是一个随机地址；如下演示，it的值是一个随机数：</p>
<p><img src="/.xyz//vector-4-2.png" alt></p>
<h4 id="（3）pop-back"><a href="#（3）pop-back" class="headerlink" title="（3）pop_back()"></a>（3）pop_back()</h4><p>尾部删除，也不需多说；</p>
<h4 id="（4）-erase"><a href="#（4）-erase" class="headerlink" title="（4） erase()"></a>（4） erase()</h4><p>指定位置或指定范围删除</p>
<p><img src="/.xyz//vector-4-3.png" alt></p>
<h4 id="此外关于移动、查询数据vector容器并没有提供相应的方法，移动只能通过删除再添加来实现，不过查找我们可以通过stl库提供的find函数来实现"><a href="#此外关于移动、查询数据vector容器并没有提供相应的方法，移动只能通过删除再添加来实现，不过查找我们可以通过stl库提供的find函数来实现" class="headerlink" title="此外关于移动、查询数据vector容器并没有提供相应的方法，移动只能通过删除再添加来实现，不过查找我们可以通过stl库提供的find函数来实现"></a>此外关于移动、查询数据vector容器并没有提供相应的方法，移动只能通过删除再添加来实现，不过查找我们可以通过stl库提供的find函数来实现</h4><pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
int main()
{
       vector&lt;int&gt; a={1,2,3,4,5};
    /*find函数返回值是一个指针*/
    vector&lt;int&gt;::iterator it=find(a.begin(),a.end(),3);
    cout&lt;&lt;*it&lt;&lt;endl;
    /*可以通过指针相减得到序列号*/
    cout&lt;&lt;&quot;position:&quot;&lt;&lt;it-a.begin()&lt;&lt;endl;
    return 0;
}</code></pre><p><img src="/.xyz//vector-4-4.png" alt></p>
<p>关于vector常用的方法大概就这么多了，以后遇到可以在进行补充^_^~</p>
<h5 id="对彼此的情感，他们一句话也不提。沉默也有某种魔力，就像最漂亮脆弱的肥皂泡升到时空中，清晰可见，五彩斑斓，可最好是不要去碰它。有一天，玛丽娅想她的父母嘴边是否经常挂着爱呢。她猜得很准，他们很少说；在他们幸福的婚姻中，无须提起如此肯定、毋庸置疑的那份情感。—-《岛》"><a href="#对彼此的情感，他们一句话也不提。沉默也有某种魔力，就像最漂亮脆弱的肥皂泡升到时空中，清晰可见，五彩斑斓，可最好是不要去碰它。有一天，玛丽娅想她的父母嘴边是否经常挂着爱呢。她猜得很准，他们很少说；在他们幸福的婚姻中，无须提起如此肯定、毋庸置疑的那份情感。—-《岛》" class="headerlink" title="对彼此的情感，他们一句话也不提。沉默也有某种魔力，就像最漂亮脆弱的肥皂泡升到时空中，清晰可见，五彩斑斓，可最好是不要去碰它。有一天，玛丽娅想她的父母嘴边是否经常挂着爱呢。她猜得很准，他们很少说；在他们幸福的婚姻中，无须提起如此肯定、毋庸置疑的那份情感。—-《岛》"></a><em>对彼此的情感，他们一句话也不提。沉默也有某种魔力，就像最漂亮脆弱的肥皂泡升到时空中，清晰可见，五彩斑斓，可最好是不要去碰它。有一天，玛丽娅想她的父母嘴边是否经常挂着爱呢。她猜得很准，他们很少说；在他们幸福的婚姻中，无须提起如此肯定、毋庸置疑的那份情感。—-《岛》</em></h5>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>-vector</tag>
      </tags>
  </entry>
  <entry>
    <title>对STL中可排序容器的总结与分析</title>
    <url>/2020/04/06/%E5%AF%B9STL%E4%B8%AD%E5%8F%AF%E6%8E%92%E5%BA%8F%E5%AE%B9%E5%99%A8%E7%9A%84%E6%80%BB%E7%BB%93%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="一、set"><a href="#一、set" class="headerlink" title="一、set"></a>一、set</h2><h3 id="（1）实现机制"><a href="#（1）实现机制" class="headerlink" title="（1）实现机制"></a>（1）实现机制</h3><p>以下叙述引自<a href="http://www.cplusplus.com/reference/set/set/" target="_blank" rel="noopener">C++ reference</a></p>
<blockquote>
<p>Sets are containers that store unique elements following a specific order.<br>In a set, the value of an element also identifies it (the value is itself the key, of type T), and each value must be unique. The value of the elements in a set cannot be modified once in the container (the elements are always const), but they can be inserted or removed from the container.</p>
</blockquote>
<blockquote>
<p>set containers are generally slower than unordered_set containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.</p>
</blockquote>
<blockquote>
<p>Sets are typically implemented as binary search trees.</p>
</blockquote>
<p>　　翻译大意就是：<br>　　set是一个特殊的存储非重复元素的有特定顺序的容器，另外还需注意的是，set中的元素不可更改，元素一直都是常数（当然可以增添和删除）；<br><br>　　set容器通常比unordered_set容器通过它们的键访问单个元素的速度慢，但是它们允许根据它们的顺序对子集进行直接迭代；<br><br>　　set就是一颗二叉搜索树典型的实现。</p>
<h3 id="2-使用构造函数实现排序"><a href="#2-使用构造函数实现排序" class="headerlink" title="(2) 使用构造函数实现排序"></a>(2) 使用构造函数实现排序</h3><h4 id="1-默认构造函数，升序排序"><a href="#1-默认构造函数，升序排序" class="headerlink" title="1.默认构造函数，升序排序"></a>1.默认构造函数，升序排序</h4><pre><code>set&lt;int&gt; aa;
aa.insert(5);
aa.insert(8);
aa.insert(1);</code></pre><h4 id="2-使用functional头文件中的less，greater实现基本数据类型排序"><a href="#2-使用functional头文件中的less，greater实现基本数据类型排序" class="headerlink" title="2.使用functional头文件中的less，greater实现基本数据类型排序"></a>2.使用functional头文件中的less，greater实现基本数据类型排序</h4><p>其中greater是降序排序，less是升序排序，可能从名字上看是相反的，但他们的命名是由其实现决定的，比如greater内部实现通过重载”&lt;”,来实现”&gt;”的功能：</p>
<pre><code>set&lt;int,greater&lt;int&gt; &gt; a;
a.insert(5);
a.insert(8);
a.insert(1);</code></pre><h4 id="3-自定义结构体或类-，重载（）运算符排序"><a href="#3-自定义结构体或类-，重载（）运算符排序" class="headerlink" title="3.自定义结构体或类 ，重载（）运算符排序"></a>3.自定义结构体或类 ，重载（）运算符排序</h4><pre><code>struct cmp {
bool operator() (const int&amp; lhs, const int&amp; rhs) const
{return lhs&gt;rhs;}
};

set&lt;int,cmp&gt; aa;
aa.insert(5);
aa.insert(8);
aa.insert(1);</code></pre><h4 id="4-对自定义的结构体排序"><a href="#4-对自定义的结构体排序" class="headerlink" title="4.对自定义的结构体排序"></a>4.对自定义的结构体排序</h4><p>以上三种排序方法都是对基本数据类型的排序，那么当需要对自定义的结构体进行排序时怎么办呢？可以类似于上一种，在结构体中重载”&lt;”运算符就可以了；</p>
<pre><code>struct Node{
int a;
int b;
Node(int _a,int _b):a(_a),b(_b){}
bool operator &lt; (const Node&amp; rhs) const{
    return a != rhs.a ? a &gt; rhs.a : b &gt; rhs.b;//以a为第一比较标准，当a相等时比较b，降序排列
}
};

int main(){
set&lt;Node&gt; aaa;
aaa.insert(Node(2,3));
aaa.insert(Node(2,4));
aaa.insert(Node(3,3));
aaa.insert(Node(4,3));
}</code></pre><p>###（3） 对重载符号的讨论 ###<br>看到这里，可能会有同学疑问，为什么两个自定义结构体进行排序重载的运算符不同呢？我们不妨先来看一下set的构造函数<br><br>有参：</p>
<pre><code>set (InputIterator first, InputIterator last,
   const key_compare&amp; comp = key_compare(),
   const allocator_type&amp; = allocator_type());</code></pre><p>无参(即我们只在&lt;&gt;里面声明了数据类型并不是完全无参）：</p>
<pre><code>explicit set (const allocator_type&amp; alloc);</code></pre><p>当无参的时候，默认的排序方法是使用“&lt;”对元素进行比较，所以当我们对自己定义的结构体进行排序时只需要重载&lt;运算符就可以了，当然我们也可以像前面一种方法一样，重载（）运算符，如下：</p>
<pre><code>struct Node{
int a;
int b;
Node(int _a,int _b):a(_a),b(_b){}
/*bool operator &lt; (const Node&amp; rhs) const{
    return a != rhs.a ? a &gt; rhs.a : b &gt; rhs.b;//以a为第一比较标准，当a相等时比较b，降序排列
}*/
};
struct cmp {
  bool operator () (const Node&amp; lhs, const Node&amp; rhs) const
  {return lhs.a != rhs.a ? lhs.a &gt; rhs.a : lhs.b &gt; rhs.b;}
};
int main()
{
set&lt;Node,cmp&gt; aaa;
aaa.insert(Node(2,3));
aaa.insert(Node(2,4));
aaa.insert(Node(3,3));
aaa.insert(Node(4,3));
}</code></pre><p>实现的功能和上述完全相同，只不过代码一下子变得臃肿起来，不仅需要自定义结构体，还有另外定义一个比较函数的结构体；</p>
<h3 id="（4）set容器排序总结"><a href="#（4）set容器排序总结" class="headerlink" title="（4）set容器排序总结"></a>（4）set容器排序总结</h3><p>当需要对基本数据类型进行排序时，建议使用functional头文件中的less和greater模板如（2）2，可以极大地减少代码量，当需要对自定义结构体进行排序时，可以在自定义的结构体中重载&lt;运算符，如（2）4所示。</p>
<h2 id="二、map"><a href="#二、map" class="headerlink" title="二、map"></a>二、map</h2><h3 id="（1）实现机制-1"><a href="#（1）实现机制-1" class="headerlink" title="（1）实现机制"></a>（1）实现机制</h3><p>以下叙述引自<a href="http://www.cplusplus.com/reference/map/map/" target="_blank" rel="noopener">C++ reference</a></p>
<blockquote>
<p>Maps are associative containers that store elements formed by a combination of a key value and a mapped value, following a specific order.</p>
</blockquote>
<blockquote>
<p>In a map, the key values are generally used to sort and uniquely identify the elements, while the mapped values store the content associated to this key. The types of key and mapped value may differ, and are grouped together in member type value_type, which is a pair type combining both:</p>
</blockquote>
<pre><code>typedef pair&lt;const Key, T&gt; value_type;</code></pre><blockquote>
<p>Internally, the elements in a map are always sorted by its key following a specific strict weak ordering criterion indicated by its internal comparison object (of type Compare).</p>
</blockquote>
<blockquote>
<p>map containers are generally slower than unordered_map containers to access individual elements by their key, but they allow the direct iteration on subsets based on their order.</p>
</blockquote>
<blockquote>
<p>The mapped values in a map can be accessed directly by their corresponding key using the bracket operator ((operator[]).</p>
</blockquote>
<blockquote>
<p>Maps are typically implemented as binary search trees.</p>
</blockquote>
<p>翻译大意：map容器是一个组合的容器用来存储键和它映射的值，遵循一种特殊的排序方式；排序根据key排序；map容器通常比unordered_map容器通过它们的键访问单个元素的速度慢，但是它们允许根据它们的顺序对子集进行直接迭代。map容器也允许通过数组形式来访问，比如_map[key],下表为键。map容器是二叉搜索树的实现。<br>其实，可以这样理解，map是一个结构体类型的set，结构体中包含键与值两个数据。当然肯定不会只是这么简单的如此。</p>
<h3 id="（2）使用构造函数实现排序"><a href="#（2）使用构造函数实现排序" class="headerlink" title="（2）使用构造函数实现排序"></a>（2）使用构造函数实现排序</h3><h4 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1.默认构造函数"></a>1.默认构造函数</h4><p>按照key值升序排列</p>
<pre><code>map&lt;char,int&gt; first;
  first[&apos;a&apos;]=10;
  first[&apos;b&apos;]=30;
  first[&apos;c&apos;]=50;
  first[&apos;d&apos;]=70;</code></pre><h4 id="2-使用functional头文件"><a href="#2-使用functional头文件" class="headerlink" title="2.使用functional头文件"></a>2.使用functional头文件</h4><pre><code>std::map&lt;char,int,std::greater&lt;char&gt; &gt; first;
  first[&apos;a&apos;]=10;
  first[&apos;b&apos;]=30;
  first[&apos;c&apos;]=50;
  first[&apos;d&apos;]=70;</code></pre><h4 id="3-为自定义结构体排序"><a href="#3-为自定义结构体排序" class="headerlink" title="3.为自定义结构体排序"></a>3.为自定义结构体排序</h4><p>类比于set的自定义结构体排序，也可以有两种不同的重载方法，其一是在自定义的结构体内部重载&lt;运算符，调用仍使用无参构造函数（即只有键值两参数），其二是再另外创建一个结构体或类重载（）运算符，调用时需在第三个参数处调用；</p>
<h4 id="重载-lt"><a href="#重载-lt" class="headerlink" title="重载&lt;"></a>重载&lt;</h4><pre><code>struct Node{
int a;
int b;
Node(int _a,int _b):a(_a),b(_b){}
   bool operator &lt; (const Node&amp; rhs) const{
    return a != rhs.a ? a &gt; rhs.a : b &gt; rhs.b;//以a为第一比较标准，当a相等时比较b，降序排列
} 
};
int main(){
std::map&lt;Node,int&gt; first;
  first[Node(2,3)]=10;
  first[Node(2,2)]=30;
  first[Node(3,3)]=50;
  first[Node(4,3)]=70;
}</code></pre><h4 id="重载（）"><a href="#重载（）" class="headerlink" title="重载（）"></a>重载（）</h4><pre><code>struct Node{
int a;
int b;
Node(int _a,int _b):a(_a),b(_b){}
   /*bool operator &lt; (const Node&amp; rhs) const{
    return a != rhs.a ? a &gt; rhs.a : b &gt; rhs.b;//以a为第一比较标准，当a相等时比较b，降序排列
} */
};
struct cmp {
  bool operator () (const Node&amp; lhs, const Node&amp; rhs) const
  {return lhs.a != rhs.a ? lhs.a &gt; rhs.a : lhs.b &gt; rhs.b;}
};
int main ()
{
  std::map&lt;Node,int,cmp&gt; first;
  first[Node(2,3)]=10;
  first[Node(2,2)]=30;
  first[Node(3,3)]=50;
  first[Node(4,3)]=70;</code></pre><p>上述两种重载方法都是一样的，以第一种较为简便。对&lt;的重载都是对std::less的重载，模板可以参考下<a href="https://www.cnblogs.com/stay-alive/p/8215400.html" target="_blank" rel="noopener">https://www.cnblogs.com/stay-alive/p/8215400.html</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>-STL</tag>
      </tags>
  </entry>
  <entry>
    <title>dijsktra（迪杰斯特拉算法回顾与本质思想探索）</title>
    <url>/2020/03/23/dijsktra%EF%BC%88%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE%E4%B8%8E%E6%9C%AC%E8%B4%A8%E6%80%9D%E6%83%B3%E6%8E%A2%E7%B4%A2%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>Dijkstra(迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。Dijkstra一般的表述通常有两种方式，一种用永久和临时标号方式，一种是用OPEN, CLOSE表的方式，这里均采用永久和临时标号的方式。注意该算法要求图中不存在负权边。  –360百科</p>
</blockquote>
<h3 id="算法思想阐述："><a href="#算法思想阐述：" class="headerlink" title="算法思想阐述："></a>算法思想阐述：</h3><p>迪杰斯特拉算法想要达成的目的是：从图（有向无向均可）中的某个节点出发，寻找到其他节点的最短距离，算法思想采用了一部分贪心思想和一部分dp思想。贪心思想即是想着：我要寻找目前的能和我连接的最短边，最贪心的就是所有的点都在最短路径上；而dp思想则想深了一层是：记录下这个最短路径吧，万一以后出现更短的呢，我就把它换掉！举个栗子，比如下面的图：<br>&lt;img src=”images/example.png/&gt;</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>-迪杰斯特拉算法 -图最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title>对vscodeC++11标准的环境配置</title>
    <url>/2020/03/19/%E5%AF%B9vscodeC-11%E6%A0%87%E5%87%86%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>自从学了java以后，发现自己对C++有些疏于练习了，因为很多地方java的优势性和应用性是强于c语言的。当然，这是对普通的编码工作来说，C语言在造轮子方面有他无与伦比的优势，甚至C语言可以直接用来写操作系统。但是虽然C有些不方便，C++却因为它强大的stl库流行于学生之间，计算机专业的考研大纲规定，只允许用C/C++来编程，于是我又赶回来复习C++，但却突然发现，大一时候的工具用起来都不太爽利，codeblocks有时候会出现一些小bug（个人印象），dev虽然功能强大，适合初学者，但是在大量的编码工作时，由于缺少代码提示，所以使用起来也不太方便，visual studio又由于它的笨重型（超达20多个G）不适合成为中小型CPP的编写工具，于是我就只能另寻轻量级的编辑器，通过加载插件和配置环境的方法来实现，他就是VSCode。<br><br>其实，dev会作为很多比赛的官方编程软件，熟悉的使用它会很有帮助，我个人原因是因为当对stl库进行调试时，无法看到stl变量的值，于是通过网上铺天盖地的教程配置了C++环境，很多教程都说的很清楚了，我就总结一下各个部分实现的功能。</p>
<h3 id="一、launch-json"><a href="#一、launch-json" class="headerlink" title="一、launch.json"></a>一、launch.json</h3><pre><code>{
&quot;version&quot;: &quot;0.2.0&quot;,
&quot;configurations&quot;: [
    {
        &quot;name&quot;: &quot;TDM_GCC(gdb) Launch&quot;,    // 配置名称，将会在启动配置的下拉菜单中显示
        &quot;type&quot;: &quot;cppdbg&quot;,         // 配置类型，这里只能为cppdbg
        &quot;request&quot;: &quot;launch&quot;,    // 请求配置类型，可以为launch（启动）或attach（附加）
        &quot;program&quot;: &quot;${workspaceRoot}/${fileBasenameNoExtension}.exe&quot;,// 将要进行调试的程序的路径
        &quot;args&quot;: [],                // 程序调试时传递给程序的命令行参数，一般设为空即可
        &quot;stopAtEntry&quot;: false,     // 设为true时程序将暂停在程序入口处，一般设置为false
        &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,// 调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录
        &quot;environment&quot;: [],
        &quot;externalConsole&quot;: true,// 调试时是否显示控制台窗口，一般设置为true显示控制台
        &quot;MIMode&quot;: &quot;gdb&quot;,
        &quot;miDebuggerPath&quot;: &quot;E:\\TDM-GCC-64\\bin\\gdb.exe&quot;,// miDebugger的路径，注意这里要与MinGw的路径对应
        &quot;preLaunchTask&quot;: &quot;g++&quot;,    // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc
        &quot;setupCommands&quot;: [
            {
                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,
                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,
                &quot;ignoreFailures&quot;: true
            }
        ]
    }
]
}</code></pre><p>.json是配置文件的后缀,其中”version”为版本属性，在生成时出现；”configurations”是配置的具体信息，包括配置名字（会出现在调试界面的下拉框里），命令参数，以及debugger程序的路径等等，具体都有注释说明，configurations后面的<code>[]</code>里面是一整套配置，若想添加其他配置可以用逗号分隔来添加；</p>
<h3 id="二、tasks-json文件"><a href="#二、tasks-json文件" class="headerlink" title="二、tasks.json文件"></a>二、tasks.json文件</h3><pre><code>{
&quot;version&quot;: &quot;2.0.0&quot;,
&quot;command&quot;: &quot;g++&quot;,
&quot;args&quot;: [&quot;-std=c++11&quot;,&quot;-g&quot;,&quot;${file}&quot;,&quot;-o&quot;,&quot;${fileBasenameNoExtension}.exe&quot;],
&quot;problemMatcher&quot;: {
    &quot;owner&quot;: &quot;cpp&quot;,
    &quot;fileLocation&quot;: [&quot;relative&quot;, &quot;${workspaceRoot}&quot;],
    &quot;pattern&quot;: {
        &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$&quot;,
        &quot;file&quot;: 1,
        &quot;line&quot;: 2,
        &quot;column&quot;: 3,
        &quot;severity&quot;: 4,
        &quot;message&quot;: 5
    }
}
  }</code></pre><p>command命令后就是编译命令如g,gcc,g++等等，一般都用g++，C与C++都可以编译；args就是后面跟着的产出文件，因为我特意为了11标准来配置的，所以我在那些教程之外额外添加了”-std=c++11”命令，可以编译一些方便快捷的代码，比如无序哈希表，for循环，如下所示：</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include &lt;unordered_map&gt;
#include &lt;string&gt;
using namespace std;
int main()
{
    vector&lt;int&gt; list;
    unordered_map&lt;int,int&gt; _map;
    string str=&quot;12346679&quot;;
    for(char c:str)
    {
        cout&lt;&lt;c&lt;&lt;endl;
    }
    list.push_back(5);
    list.push_back(4);
    list.push_back(3);
    _map[0]=8;
    _map[5]=10;
    system(&quot;pause&quot;);
    return 0;
}</code></pre><h3 id="三、c-cpp-properties-json文件"><a href="#三、c-cpp-properties-json文件" class="headerlink" title="三、c_cpp_properties.json文件"></a>三、c_cpp_properties.json文件</h3><p>此文件是在无法识别头文件时使用，但由于我先前使用过codeblocks，dev等软件，头文件路径无需更改，所以没有创建此文件，但是对很多新手来说，没有使用过dev等可能也用不到这个编辑器，所以此处就不多说啦，若有需要网上到处都是，嘻嘻^_^!!</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>本文是对自己的一个小小总结，也希望这篇默默无闻的博文能帮到一些朋友（猛男哭泣.jpg）</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>-工具</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次晚饭杂感</title>
    <url>/2020/03/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%99%9A%E9%A5%AD%E6%9D%82%E6%84%9F/</url>
    <content><![CDATA[<p>&emsp;&emsp;<strong>晚</strong>饭前，我意外看到研究生复试大多要考英语听力的消息，瞬时慌了一下。毕竟我当初下决心要考研就是因为初试英语不考听力,虽然说复试中的英语比例没有那么大，但是想到就很慌的有木有！！！<del>_</del>一时间都不知道该不该继续考研这个决定了，因为很有可能自己努力了一年最后却没有收获，而且也失去了秋招春招的机会。可能有人会说你那么想考可以二战啊，但是家里经济情况不允许，虽然不至于供不起我，但是想到还是会很愧疚的啊，不想再平白的被养一年。<br><br>　　到了吃晚饭的时候，一如既往地跟我妈讨论买房的问题，我问妈妈说假如有一套200平的房子因为发生了凶杀案只卖20万你买不买？我妈摇了摇头，转而跟我说起了另一件事。“你知不知道，高唐（我们县城）有一套房子（大概八九十平的样子）只卖11万？”，我说：“不知道啊，为啥？难道也发生了凶杀案？”。“虽然不是凶杀案，但是也差不多了，据说夫妻两人，老婆跳楼了，因为谣传说是男的把女的推下去的，男的也上吊了，不知道上吊原因是愧疚还是别的原因，只剩下一个刚上初中的女儿”，我瞬时惊了一下“啊，上吊，为啥要上吊死啊，买个药喝了不好吗（关注点清奇）？”。我妈白了我一眼，没理我，继续回忆起了那件二十多年前的事情。“后来，那个女儿在她阿姨家生活，我也是在别人的谈话中才了解到原来跳楼的女人和我是一个庄里的，她比我大三岁。小女孩的父母突然决定离世，不知道为什么如此决然，丝毫不考虑自己的孩子。可是你以为关于这家人悲惨的命运就这样了吗？跳楼女人还有个哥哥，原来在东北过活，后来意外被疯狗咬到后突然疯了，于是就回到了老家，躺在床上不能自理，成了周边的大人吓唬小孩子的狼外婆：‘你不要去他家奥，他家里有害了狂犬病的，听见人声就要跳上来将咬你一口！’，于是小孩子就被吓得不敢靠近他家，觉得那里是个妖魔鬼怪的居所。这个男人疯了以后不久，他的老婆就带着一个儿子走了。可能有很多人潜意识里觉得农村的妇女思想封建，还会为死去的或者瘫痪的丈夫守寡什么的，但其实没有，每个人都是现实的，没有谁会为了一个贞节牌坊放弃自己的后半生。像书中的人物还是少之又少，而且我本人也不太赞成那样的做法，何苦为了一个已经不在的人再去为难自己呢？言归正传，在不久后的后来，疯了的男人的父亲老死了，作为唯一一个孙子，小孩子回到这个村子里参加葬礼，小孩子的奶奶也把自己不舍得花的积储都给了他，出乎意料的，本来已经断绝了好几年来往的两辈又来往了起来。但是好景不长，又过了好几年之后，孩子的奶奶也老了，孩子也不再来了。无人照料无人问津的疯男人也不知如何的没有了一点消息，也许是饿死在了那张他长躺的床铺之上。故事到这里就结束了，有点凄凉但很现实的一个真实故事。<br><br>　　在命运与生活面前，没有最不幸只有更不幸，谁也无法预料自己的生活将是什么。听完妈妈讲的故事后，因为英语复试听力考试的那些慌张失措彷徨不安瞬间消了大半。在整个人生面前，那么长久的时间对上这短小的考研一年，似乎很轻易的就战胜了。人生那么多不幸，那么多失意，那么多障碍，总是需要一步一步的去度过的，不管有多么艰难，硬着头皮，尽最大的努力往前冲，做过之后再回首其实没什么的吧！虽然有可能会失败，障碍没有被跃过反而将自己绊倒，也许此时的自己不知如何重新站起，但是，时间会告诉你一切，在长长的时间里，做好最坏的打算，做好心理的预设，但同时不要忘了尽好最大的努力，只要不被击得粉碎，沉稳的等到那个障碍来临，你的选择是沉默还是爆发，是一拳击碎扶摇万里还是跌跌撞撞再起河山亦其实都无所谓，只要看到便足够！
　　</p>
]]></content>
      <categories>
        <category>心情日志</category>
      </categories>
      <tags>
        <tag>-心情 -成长</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中各类型的相互转化方法总结</title>
    <url>/2020/03/06/Java%E4%B8%AD%E5%90%84%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E5%8C%96%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做java有关的力扣题时，发现自己对java的一些基础知识和基本语法还不是很熟练，所谓“一屋不扫，何以扫天下”，“千里之行，始于足下”，所以此时我决定将一些基础的但却不引人重视的java语法整理一下，方便自己的随时查看和复习，在以后也会有更多的内容归类到这个标签下。本次整理的主题是java类型的转化方法。</p>
<h2 id="一、各类型转化为String"><a href="#一、各类型转化为String" class="headerlink" title="一、各类型转化为String"></a>一、各类型转化为String</h2><h3 id="1-int转化为String"><a href="#1-int转化为String" class="headerlink" title="1. int转化为String"></a>1. int转化为String</h3><p>   int与String之间不能相互直接转化，因为int是java语法中的基本类型，而String是一个类，import自java.util,但可以间接转化：</p>
<pre><code>int a=0;
Integer inter=new Integer(a);
String str=inter.toString();</code></pre><h3 id="2-float转化为String"><a href="#2-float转化为String" class="headerlink" title="2.float转化为String"></a>2.float转化为String</h3><p>与int的转化同理：</p>
<pre><code>float f=3.1415f;
Float flo=new Float(f);
String str=flo.toString();</code></pre><h3 id="3-double转化为String"><a href="#3-double转化为String" class="headerlink" title="3.double转化为String"></a>3.double转化为String</h3><pre><code> double d=3.1415;
Double dou=new Double(d);
String str2=dou.toString();</code></pre><h2 id="二、String-转化为各类型"><a href="#二、String-转化为各类型" class="headerlink" title="二、String 转化为各类型"></a>二、String 转化为各类型</h2><h3 id="1-String转化为int"><a href="#1-String转化为int" class="headerlink" title="1.String转化为int"></a>1.String转化为int</h3><pre><code>int i=Integer.parseInt(str);</code></pre><h3 id="2-String转化为Integer"><a href="#2-String转化为Integer" class="headerlink" title="2.String转化为Integer"></a>2.String转化为Integer</h3><pre><code>Integer inter = Integer.valueOf(str);</code></pre><h3 id="3-String转化为float"><a href="#3-String转化为float" class="headerlink" title="3.String转化为float"></a>3.String转化为float</h3><p>方法float,double,int其实都差不多</p>
<pre><code>float f=Float.parseFloat(str);</code></pre><h2 id="三、int、float、double之间的相互转换"><a href="#三、int、float、double之间的相互转换" class="headerlink" title="三、int、float、double之间的相互转换"></a>三、int、float、double之间的相互转换</h2><p><strong>注意：尽量由小字节向高字节转化，否则易发生数据错误</strong></p>
<h3 id="1-int-gt-float、float-gt-double"><a href="#1-int-gt-float、float-gt-double" class="headerlink" title="1.int-&gt;float、float-&gt;double"></a>1.int-&gt;float、float-&gt;double</h3><pre><code>int i=3;
float f=i;
double d=f;
double d=i;</code></pre><p>自动转化即可。</p>
<h3 id="2-反之"><a href="#2-反之" class="headerlink" title="2.反之"></a>2.反之</h3><p>则需要强制转化</p>
<pre><code>double d=3.1415;
float f =(float)d;</code></pre>]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>-java -基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>firstblog</title>
    <url>/2020/03/02/firstblog/</url>
    <content><![CDATA[<h1 id="历经"><a href="#历经" class="headerlink" title="历经"></a>历经</h1><p>将近<strong>半个月</strong>的时间，经历了<em>选择域名，选择云服务器，再选择web服务器</em>的种种过程后，终于还是发现github的pages空间是最棒的，且不说githubpages作为美国的网站免备案，更是由于其免费，快捷，托管的巨大优势成为小型blog的首选。</p>
<h1 id="选择过程"><a href="#选择过程" class="headerlink" title="选择过程"></a>选择过程</h1><h2 id="一、域名与服务器"><a href="#一、域名与服务器" class="headerlink" title="一、域名与服务器"></a>一、域名与服务器</h2><p>意外的，通过腾讯云的一元钱域名入了此坑，选择了最便宜的.xyz域名,而且腾讯云还体贴的送了十五天的云服务器体验时间，于是在最初里我通过tomcat和javaee创建了一个简单的小网页，本想继续深造，却突然发现，腾讯云这么好不是没有原因的。备案是其一，服务器的超贵价格是其二，一年居然要将近1000rmb，无奈放弃；</p>
<h2 id="二、了解githubpages"><a href="#二、了解githubpages" class="headerlink" title="二、了解githubpages"></a>二、了解githubpages</h2><p>其实github我也是已经注册了很久的一段时间了，却一直没有好好的利用这个全球最先进的分布式系统。githubpages的本意是为人们的项目提供一个简洁明了的介绍页面，但因为其免费快捷可托管的特性，意外的被当做了小型blog的云服务器。关于这点，很多人也有争议，认为这是一种蝗虫行为。</p>
<blockquote>
<p>说中国人是蝗虫还真是不错，github被屏蔽了你就开心了？就像蝗虫，有好东西一拥而上，生怕自己抢不到，吃光了或不抢不过了就换下一个地方，继续搞。<br>这种东西需要写篇文章来宣传么，不知道宣传了以后的后果么，本来是个挺好的社区博客，有可能会因为你这一篇文章，搞的大家以后都用不了了，麻烦作者以后发文章前先考虑对社会的影响，对社区的影响，顾全大局…</p>
</blockquote>
<p>也有人认为这种行为是全球网络和谐的前提和征兆：</p>
<blockquote>
<p>就算 github 真的被墙了，错的也是弄出墙的这些人，跟博主有半毛钱关系？<br>看到好的东西不分享出来，自己偷摸留着，这算什么心态？<br>见到出色的产品，我觉得最好的做法就是像博主一样毫无保留的介绍给别人，方便的话也捎带介绍一下墙是什么。人都有自己的判断力的，能通过对比分出好坏，能想明白他在网上受到了多大限制，为什么一些国外网站不被允许访问。<br>github 是好东西，但藏着不让大伙知道就可以不被墙了？我不这么看，反倒是当每个网民都知道事实的时候，就离墙消失的一天不远了，那时候大家安心的去用 github 不是更好吗？</p>
</blockquote>
<p>但是其实针对博客在githubpages上的创建，在两年前就已经有牛人开发了hexo，专门用来帮助快捷的创建博客，甚至还有多款主题，而github也因此发展出了一个pull分支，就是围绕hexo编写主题。可以说这种行为其实是促进了代码的贡献的，我个人比较倾向于后一种看法！</p>
]]></content>
      <categories>
        <category>前沿技术</category>
      </categories>
      <tags>
        <tag>-技术 -IT</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/02/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
